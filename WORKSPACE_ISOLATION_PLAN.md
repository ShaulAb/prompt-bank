# Workspace Isolation Implementation Plan

**Issue**: #53 - Sync mixes prompts across different workspaces/projects
**Branch**: `fix/workspace-isolation-sync-bug`
**Approach**: Option 1 - Add `workspace_id` to cloud schema

## Implementation Strategy

Add a `workspace_id` field to existing `user_prompts` table and filter all sync operations by workspace. Workspace ID is generated by hashing the workspace root path.

---

## Phase 1: Database Schema Changes

### 1.1 Create Migration SQL

**File**: `supabase/migrations/YYYYMMDD_add_workspace_id.sql`

```sql
-- Add workspace_id column (nullable for backward compatibility)
ALTER TABLE user_prompts
ADD COLUMN workspace_id VARCHAR(16) DEFAULT NULL;

-- Add index for efficient filtering
CREATE INDEX idx_user_prompts_workspace
ON user_prompts(user_id, workspace_id);

-- Add composite index for common queries
CREATE INDEX idx_user_prompts_user_workspace_updated
ON user_prompts(user_id, workspace_id, updated_at DESC);

-- Update unique constraint to include workspace_id
-- This allows same local_id across different workspaces
ALTER TABLE user_prompts
DROP CONSTRAINT IF EXISTS user_prompts_user_id_local_id_key;

ALTER TABLE user_prompts
ADD CONSTRAINT user_prompts_user_workspace_local_unique
UNIQUE (user_id, workspace_id, local_id);

-- Assign existing prompts to a default workspace
-- This prevents existing prompts from mixing with new workspaces
UPDATE user_prompts
SET workspace_id = '0000000000000000'
WHERE workspace_id IS NULL;

-- Make workspace_id NOT NULL after migration
ALTER TABLE user_prompts
ALTER COLUMN workspace_id SET NOT NULL;

-- Add comment for documentation
COMMENT ON COLUMN user_prompts.workspace_id IS
'SHA256 hash (first 16 chars) of workspace root path. Isolates prompts per VS Code workspace.';
```

**Status**: â¬œ TODO

---

### 1.2 Apply Migration

**Commands**:
```bash
# If using Supabase CLI locally
supabase db reset  # Apply all migrations

# OR manually via Supabase Dashboard
# - Navigate to SQL Editor
# - Paste migration SQL
# - Execute
```

**Verification**:
```sql
-- Check column exists
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'user_prompts'
  AND column_name = 'workspace_id';

-- Check indexes
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'user_prompts'
  AND indexname LIKE '%workspace%';

-- Check existing data migration
SELECT workspace_id, COUNT(*)
FROM user_prompts
GROUP BY workspace_id;
```

**Status**: â¬œ TODO

---

## Phase 2: TypeScript Models Update

### 2.1 Update RemotePrompt Interface

**File**: `src/models/syncState.ts`

**Changes**:
```typescript
export interface RemotePrompt {
  readonly id: string;
  readonly user_id: string;
  readonly workspace_id: string; // âœ¨ NEW - workspace identifier
  readonly cloud_id: string;
  readonly local_id: string;
  readonly title: string;
  readonly content: string;
  readonly description: string | null;
  readonly category: string;
  readonly prompt_order: number | null;
  readonly category_order: number | null;
  readonly variables: unknown; // JSONB
  readonly metadata: unknown; // JSONB
  readonly sync_metadata: unknown; // JSONB
  readonly version: number;
  readonly content_hash: string;
  readonly created_at: string; // ISO timestamp
  readonly updated_at: string; // ISO timestamp
  readonly deleted_at?: string | null; // ISO timestamp (soft delete)
  readonly deleted_by_device_id?: string | null;
}
```

**Status**: â¬œ TODO

---

### 2.2 Update SyncState Interface

**File**: `src/models/syncState.ts`

**Changes**:
```typescript
export interface SyncState {
  /** User's email from Google OAuth (unique identifier) */
  readonly userId: string;

  /** Stable device identifier (persists across sessions) */
  readonly deviceId: string;

  /** Human-readable device name (e.g., "MacBook Pro (Mac)") */
  readonly deviceName: string;

  /** Workspace identifier (hash of workspace root path) */
  readonly workspaceId: string; // âœ¨ NEW

  /** Last successful sync timestamp */
  lastSyncedAt?: Date;

  /** Map: promptId â†’ sync information for that prompt */
  promptSyncMap: Readonly<Record<string, PromptSyncInfo>>;

  /** Schema version for future migrations (default: 3 with workspace support) */
  schemaVersion?: number;
}
```

**Update factory function**:
```typescript
export const createEmptySyncState = (
  userId: string,
  deviceId: string,
  deviceName: string,
  workspaceId: string // âœ¨ NEW parameter
): SyncState => ({
  userId,
  deviceId,
  deviceName,
  workspaceId, // âœ¨ NEW
  promptSyncMap: Object.freeze({}),
  schemaVersion: 3, // Bump version for workspace support
});
```

**Status**: â¬œ TODO

---

## Phase 3: Workspace ID Generation

### 3.1 Create Workspace ID Utility

**File**: `src/utils/workspaceId.ts` (NEW FILE)

```typescript
import * as crypto from 'crypto';
import * as path from 'path';

/**
 * Generate stable workspace identifier from workspace root path
 *
 * Uses SHA256 hash of normalized absolute path (first 16 chars = 64 bits entropy)
 * This ensures same workspace gets same ID across different devices.
 *
 * @param workspaceRoot - Absolute path to workspace root
 * @returns 16-character hex string (workspace identifier)
 *
 * @example
 * generateWorkspaceId('/home/user/projects/my-app')
 * // => 'a1b2c3d4e5f6g7h8'
 */
export function generateWorkspaceId(workspaceRoot: string): string {
  // Normalize path to handle different OS path separators and relative paths
  const normalized = path.normalize(path.resolve(workspaceRoot));

  // Generate SHA256 hash
  const hash = crypto.createHash('sha256')
    .update(normalized)
    .digest('hex');

  // Take first 16 characters (64 bits of entropy)
  // Collision probability: ~1 in 18 quintillion
  return hash.substring(0, 16);
}

/**
 * Validate workspace ID format
 *
 * @param workspaceId - Workspace ID to validate
 * @returns True if valid format (16 hex chars)
 */
export function isValidWorkspaceId(workspaceId: string): boolean {
  return /^[a-f0-9]{16}$/i.test(workspaceId);
}
```

**Status**: â¬œ TODO

---

### 3.2 Add Tests for Workspace ID

**File**: `test/workspace-id.test.ts` (NEW FILE)

```typescript
import { describe, it, expect } from 'vitest';
import { generateWorkspaceId, isValidWorkspaceId } from '../src/utils/workspaceId';

describe('generateWorkspaceId', () => {
  it('should generate consistent IDs for same path', () => {
    const path = '/home/user/projects/my-app';
    const id1 = generateWorkspaceId(path);
    const id2 = generateWorkspaceId(path);

    expect(id1).toBe(id2);
  });

  it('should generate different IDs for different paths', () => {
    const id1 = generateWorkspaceId('/home/user/projects/app1');
    const id2 = generateWorkspaceId('/home/user/projects/app2');

    expect(id1).not.toBe(id2);
  });

  it('should normalize paths before hashing', () => {
    const id1 = generateWorkspaceId('/home/user/projects/app');
    const id2 = generateWorkspaceId('/home/user/projects/app/');
    const id3 = generateWorkspaceId('/home/user/projects/./app');

    expect(id1).toBe(id2);
    expect(id1).toBe(id3);
  });

  it('should return 16-character hex string', () => {
    const id = generateWorkspaceId('/any/path');

    expect(id).toHaveLength(16);
    expect(id).toMatch(/^[a-f0-9]{16}$/);
  });
});

describe('isValidWorkspaceId', () => {
  it('should validate correct format', () => {
    expect(isValidWorkspaceId('a1b2c3d4e5f6g7h8')).toBe(false); // g is not hex
    expect(isValidWorkspaceId('a1b2c3d4e5f67890')).toBe(true);
    expect(isValidWorkspaceId('0123456789abcdef')).toBe(true);
  });

  it('should reject invalid lengths', () => {
    expect(isValidWorkspaceId('abc')).toBe(false);
    expect(isValidWorkspaceId('a1b2c3d4e5f67890ff')).toBe(false);
  });

  it('should reject non-hex characters', () => {
    expect(isValidWorkspaceId('gggggggggggggggg')).toBe(false);
    expect(isValidWorkspaceId('a1b2c3d4e5f6-890')).toBe(false);
  });
});
```

**Status**: â¬œ TODO

---

## Phase 4: Service Layer Updates

### 4.1 Update SyncService

**File**: `src/services/syncService.ts`

**Changes**:

```typescript
export class SyncService {
  private syncStateStorage: SyncStateStorage;
  private authService: AuthService;
  private workspaceId: string; // âœ¨ NEW - computed workspace ID

  constructor(
    private context: vscode.ExtensionContext,
    workspaceRoot: string, // Keep this parameter
    authService: AuthService,
    syncStateStorage: SyncStateStorage
  ) {
    this.authService = authService;
    this.syncStateStorage = syncStateStorage;

    // âœ¨ NEW - Compute workspace ID from workspace root
    this.workspaceId = generateWorkspaceId(workspaceRoot);
  }

  // âœ¨ UPDATE - Pass workspaceId to Edge Function
  private async fetchRemotePrompts(
    since?: Date,
    includeDeleted = false
  ): Promise<readonly RemotePrompt[]> {
    const supabase = SupabaseClientManager.get();

    try {
      const { data, error } = await supabase.functions.invoke('get-user-prompts', {
        body: {
          workspaceId: this.workspaceId, // âœ¨ NEW - filter by workspace
          since: since?.toISOString(),
          includeDeleted,
        },
      });

      // ... rest of function
    }
  }

  // âœ¨ UPDATE - Include workspaceId in upload
  private async uploadPrompt(
    prompt: Prompt,
    syncInfo?: PromptSyncInfo
  ): Promise<{ cloudId: string; version: number }> {
    const supabase = SupabaseClientManager.get();
    const contentHash = computeContentHash(prompt);
    const deviceInfo = await getDeviceInfo(this.context);

    const body = {
      workspaceId: this.workspaceId, // âœ¨ NEW
      cloudId: syncInfo?.cloudId,
      expectedVersion: syncInfo?.version,
      contentHash: contentHash,
      local_id: prompt.id,
      // ... rest of body
    };

    // ... rest of function
  }

  // âœ¨ UPDATE - Pass workspaceId to delete
  private async deletePrompt(cloudId: string): Promise<void> {
    const supabase = SupabaseClientManager.get();
    const deviceInfo = await getDeviceInfo(this.context);

    const { error } = await supabase.functions.invoke('delete-prompt', {
      body: {
        workspaceId: this.workspaceId, // âœ¨ NEW
        cloudId,
        deviceId: deviceInfo.id
      },
    });

    // ... rest of function
  }

  // âœ¨ UPDATE - Pass workspaceId during sync state initialization
  private async getOrCreateSyncState(userId: string): Promise<SyncState> {
    let state = await this.syncStateStorage!.getSyncState();

    if (!state) {
      // Initialize sync state for new device
      const deviceInfo = await getDeviceInfo(this.context);
      state = await this.syncStateStorage!.initializeSyncState(
        userId,
        deviceInfo,
        this.workspaceId // âœ¨ NEW parameter
      );
    }

    return state;
  }
}
```

**Don't forget to import**:
```typescript
import { generateWorkspaceId } from '../utils/workspaceId';
```

**Status**: â¬œ TODO

---

### 4.2 Update SyncStateStorage

**File**: `src/storage/syncStateStorage.ts`

**Changes**:

```typescript
/**
 * Initialize sync state for a new device/workspace
 *
 * @param userId - User email from OAuth
 * @param deviceInfo - Device information
 * @param workspaceId - Workspace identifier (hash of workspace root)
 */
async initializeSyncState(
  userId: string,
  deviceInfo: DeviceInfo,
  workspaceId: string // âœ¨ NEW parameter
): Promise<SyncState> {
  const emptyState = createEmptySyncState(
    userId,
    deviceInfo.id,
    deviceInfo.name,
    workspaceId // âœ¨ NEW
  );

  await this.saveSyncState(emptyState);
  return emptyState;
}
```

**Status**: â¬œ TODO

---

## Phase 5: Edge Functions Updates

### 5.1 Update get-user-prompts

**File**: `supabase/functions/get-user-prompts/index.ts`

**Changes**:

```typescript
Deno.serve(async (req) => {
  // ... CORS handling ...

  // ... Authentication ...

  // Parse request body
  const { workspaceId, since, includeDeleted } = await req.json(); // âœ¨ NEW workspaceId

  // âœ¨ VALIDATE workspace ID
  if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.length !== 16) {
    return new Response(
      JSON.stringify({ error: 'Invalid workspace_id' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // Build query with workspace filter
  let query = supabaseClient
    .from('user_prompts')
    .select('*')
    .eq('user_id', user.id)
    .eq('workspace_id', workspaceId); // âœ¨ NEW - filter by workspace

  if (since) {
    query = query.gte('updated_at', since);
  }

  if (!includeDeleted) {
    query = query.is('deleted_at', null);
  }

  const { data: prompts, error: fetchError } = await query;

  if (fetchError) {
    return new Response(
      JSON.stringify({ error: fetchError.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }

  return new Response(
    JSON.stringify({ prompts }),
    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
  );
});
```

**Status**: â¬œ TODO

---

### 5.2 Update sync-prompt (upsert)

**File**: `supabase/functions/sync-prompt/index.ts`

**Changes**:

```typescript
Deno.serve(async (req) => {
  // ... CORS handling ...

  // ... Authentication ...

  // Parse request body
  const {
    workspaceId, // âœ¨ NEW
    cloudId,
    expectedVersion,
    contentHash,
    local_id,
    title,
    content,
    description,
    category,
    prompt_order,
    category_order,
    variables,
    metadata,
    sync_metadata,
  } = await req.json();

  // âœ¨ VALIDATE workspace ID
  if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.length !== 16) {
    return new Response(
      JSON.stringify({ error: 'Invalid workspace_id' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // ... rest of validation ...

  // Check if updating existing prompt
  if (cloudId) {
    const { data: existing } = await supabaseClient
      .from('user_prompts')
      .select('version, deleted_at, workspace_id') // âœ¨ Include workspace_id
      .eq('cloud_id', cloudId)
      .eq('user_id', user.id)
      .single();

    if (existing) {
      // âœ¨ VERIFY workspace_id matches (prevent cross-workspace updates)
      if (existing.workspace_id !== workspaceId) {
        return new Response(
          JSON.stringify({
            error: 'WORKSPACE_MISMATCH',
            message: 'Cannot update prompt from different workspace'
          }),
          { status: 403, headers: { 'Content-Type': 'application/json' } }
        );
      }

      // ... rest of conflict checks (version, deleted_at) ...
    }
  }

  // Generate cloud_id if not provided
  const finalCloudId = cloudId || crypto.randomUUID();

  // Upsert prompt with workspace_id
  const { data, error } = await supabaseClient
    .from('user_prompts')
    .upsert({
      user_id: user.id,
      workspace_id: workspaceId, // âœ¨ NEW
      cloud_id: finalCloudId,
      local_id,
      title,
      content,
      description,
      category,
      prompt_order,
      category_order,
      variables,
      metadata,
      sync_metadata,
      content_hash: contentHash,
      version: expectedVersion ? expectedVersion + 1 : 1,
      updated_at: new Date().toISOString(),
    })
    .select()
    .single();

  // ... rest of function ...
});
```

**Status**: â¬œ TODO

---

### 5.3 Update delete-prompt

**File**: `supabase/functions/delete-prompt/index.ts`

**Changes**:

```typescript
Deno.serve(async (req) => {
  // ... CORS handling ...

  // ... Authentication ...

  const { workspaceId, cloudId, deviceId } = await req.json(); // âœ¨ NEW workspaceId

  // âœ¨ VALIDATE workspace ID
  if (!workspaceId || typeof workspaceId !== 'string' || workspaceId.length !== 16) {
    return new Response(
      JSON.stringify({ error: 'Invalid workspace_id' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // Soft delete prompt
  const { data, error } = await supabaseClient
    .from('user_prompts')
    .update({
      deleted_at: new Date().toISOString(),
      deleted_by_device_id: deviceId,
    })
    .eq('cloud_id', cloudId)
    .eq('user_id', user.id)
    .eq('workspace_id', workspaceId) // âœ¨ NEW - ensure same workspace
    .select()
    .single();

  if (error) {
    // Check if prompt doesn't exist
    if (error.code === 'PGRST116') {
      return new Response(
        JSON.stringify({ error: 'Prompt not found' }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }

  return new Response(
    JSON.stringify({ success: true }),
    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
  );
});
```

**Status**: â¬œ TODO

---

### 5.4 Update restore-prompt

**File**: `supabase/functions/restore-prompt/index.ts`

**Changes**: Similar to delete-prompt - add workspace_id validation

**Status**: â¬œ TODO

---

### 5.5 Update get-user-quota

**File**: `supabase/functions/get-user-quota/index.ts`

**Changes**:

```typescript
Deno.serve(async (req) => {
  // ... CORS handling ...

  // ... Authentication ...

  // âœ¨ NOTE: Quota remains GLOBAL across all workspaces
  // This is intentional - simpler UX, single limit for user
  // If per-workspace quota needed in future, add workspaceId parameter here

  // Count active prompts across ALL workspaces for this user
  const { count: promptCount } = await supabaseClient
    .from('user_prompts')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', user.id)
    .is('deleted_at', null);

  // Calculate storage across ALL workspaces
  const { data: prompts } = await supabaseClient
    .from('user_prompts')
    .select('content, title, description')
    .eq('user_id', user.id)
    .is('deleted_at', null);

  let storageBytes = 0;
  if (prompts) {
    storageBytes = prompts.reduce((total, p) => {
      return total +
        (p.content?.length || 0) +
        (p.title?.length || 0) +
        (p.description?.length || 0);
    }, 0);
  }

  const promptLimit = 1000;
  const storageLimit = 10485760; // 10 MB
  const percentageUsed = Math.round((storageBytes / storageLimit) * 100);

  return new Response(
    JSON.stringify({
      promptCount: promptCount || 0,
      promptLimit,
      storageBytes,
      storageLimit,
      percentageUsed,
    }),
    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
  );
});
```

**Status**: â¬œ TODO

---

## Phase 6: Testing

### 6.1 Unit Tests

**Files to test**:
- âœ… `test/workspace-id.test.ts` - Workspace ID generation
- ðŸ”„ `test/sync-three-way-merge.test.ts` - Update to include workspace_id
- ðŸ”„ `test/sync-service.test.ts` - Update mock responses

**New test scenarios**:
```typescript
describe('SyncService with workspace isolation', () => {
  it('should only fetch prompts for current workspace', async () => {
    // Mock remote with prompts from 2 different workspaces
    // Verify only current workspace prompts returned
  });

  it('should include workspace_id when uploading', async () => {
    // Verify upload includes workspaceId in body
  });

  it('should handle workspace mismatch errors', async () => {
    // Test 403 WORKSPACE_MISMATCH response
  });
});
```

**Status**: â¬œ TODO

---

### 6.2 Integration Tests

**Manual test scenarios**:

1. **New workspace sync**
   - Open fresh workspace (never synced before)
   - Create prompts P1, P2
   - Sync â†’ should upload to workspace_id = hash(workspace_path)
   - Verify in database

2. **Multi-workspace isolation**
   - Workspace A: Create prompts {A1, A2}
   - Workspace B: Create prompts {B1, B2}
   - Sync both
   - Verify A's prompts don't appear in B
   - Verify B's prompts don't appear in A

3. **Same workspace, different devices**
   - Device 1: Create prompt P1 in workspace
   - Device 2: Open same workspace path
   - Sync on Device 2
   - Verify P1 syncs correctly (same workspace_id)

4. **Migration from v0.7.0**
   - Install v0.7.0
   - Create prompts and sync
   - Upgrade to v0.8.0
   - Verify existing prompts assigned to default workspace
   - Verify new workspaces isolated

**Status**: â¬œ TODO

---

## Phase 7: Documentation Updates

### 7.1 Update README.md

**Section to update**: "Multi-Device Sync"

**New content**:
```markdown
### Workspace Isolation (v0.8.0+)

Each VS Code workspace has its own isolated prompt collection:

- **Workspace A** prompts stay in Workspace A
- **Workspace B** prompts stay in Workspace B
- No cross-contamination between projects

**How it works**:
- Workspace ID generated from workspace folder path
- Same workspace path = same ID across all devices
- Cloud filters prompts by workspace ID automatically

**Migrating from v0.7.0**:
- Existing prompts assigned to "default workspace"
- New workspaces start with clean slate
- To migrate old prompts: manually copy `.vscode/prompt-bank/prompts.json` to new workspace
```

**Status**: â¬œ TODO

---

### 7.2 Update CONTRIBUTING.md

**Section to update**: "Sync Architecture"

**Add workspace isolation explanation**

**Status**: â¬œ TODO

---

### 7.3 Update CHANGELOG.md

**New entry**:
```markdown
## [0.8.0] - 2025-11-XX

### Added
- **Workspace isolation for sync**: Each VS Code workspace now has isolated prompt storage in the cloud
  - Prevents prompts from mixing across different projects
  - Workspace ID automatically generated from workspace path
  - Same workspace syncs correctly across multiple devices

### Fixed
- **Critical**: Fixed bug where prompts from different workspaces mixed together during sync (#53)

### Changed
- Database schema: Added `workspace_id` column to `user_prompts` table
- Edge Functions: All sync operations now filter by workspace ID
- Sync state: Now tracks workspace ID for proper isolation

### Migration Notes
- Existing prompts automatically assigned to default workspace
- No action required for existing users
- New workspaces start with isolated prompt collections
```

**Status**: â¬œ TODO

---

## Phase 8: Deployment Checklist

### 8.1 Pre-Deployment

- [ ] Run all unit tests: `npx vitest run --isolate`
- [ ] Run type checking: `npx tsc --noEmit`
- [ ] Run code formatting: `npx prettier --check src`
- [ ] Build extension: `npm run build`
- [ ] Manual testing with 2+ workspaces
- [ ] Verify database migration on test database

**Status**: â¬œ TODO

---

### 8.2 Deployment Steps

1. **Database Migration**
   ```bash
   # Via Supabase Dashboard SQL Editor
   # Copy paste migration SQL
   # Execute and verify
   ```

2. **Deploy Edge Functions**
   ```bash
   supabase functions deploy get-user-prompts
   supabase functions deploy sync-prompt
   supabase functions deploy delete-prompt
   supabase functions deploy restore-prompt
   supabase functions deploy get-user-quota
   ```

3. **Test Edge Functions**
   ```bash
   # Use curl to test each function with workspace_id
   curl -X POST 'https://[PROJECT].supabase.co/functions/v1/get-user-prompts' \
     -H "Authorization: Bearer [TOKEN]" \
     -H "Content-Type: application/json" \
     -d '{"workspaceId":"a1b2c3d4e5f67890"}'
   ```

4. **Build and Package Extension**
   ```bash
   npm run build
   npm run package
   # Creates .vsix file
   ```

5. **Local Installation Test**
   ```bash
   code --install-extension prompt-bank-0.8.0.vsix
   # Test with multiple workspaces
   ```

6. **Create Git Tag and Release**
   ```bash
   # Will be done via GitHub Actions workflow
   # Triggers "Version Bump and Release" workflow
   ```

**Status**: â¬œ TODO

---

## Rollback Plan

If critical issues found after deployment:

1. **Edge Functions**: Deploy previous versions
   ```bash
   git checkout v0.7.0
   supabase functions deploy [function-name]
   ```

2. **Database**: workspace_id is nullable, can be ignored temporarily
   ```sql
   -- Disable workspace filtering temporarily
   -- Edge functions check: if workspace_id null, fetch all (old behavior)
   ```

3. **Extension**: Users can downgrade to v0.7.0 from marketplace

---

## Success Criteria

- [ ] Database migration completes without errors
- [ ] All Edge Functions pass validation tests
- [ ] Unit tests pass (100% coverage on new code)
- [ ] Integration tests pass (multi-workspace scenario)
- [ ] Extension builds without errors
- [ ] Manual testing confirms workspace isolation
- [ ] No prompts leak between different workspaces
- [ ] Same workspace syncs correctly across devices
- [ ] Existing users (v0.7.0) can upgrade seamlessly

---

## Timeline Estimate

**Total**: 5-7 days

- Phase 1 (Database): 1 day
- Phase 2-3 (TypeScript): 1 day
- Phase 4 (Services): 1 day
- Phase 5 (Edge Functions): 1-2 days
- Phase 6 (Testing): 1 day
- Phase 7 (Docs): 0.5 day
- Phase 8 (Deployment): 0.5 day

---

## Notes

- Workspace ID is NOT user-visible (implementation detail)
- Same workspace path on different devices = same workspace_id
- Different paths (even same project name) = different workspace_id
- Quota remains global (all workspaces share 1000 prompt limit)
- Future: Could add UI to view/manage workspaces
